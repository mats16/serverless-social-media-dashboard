AWSTemplateFormatVersion: '2010-09-09'
Description: '[Social Media Dashboard] Elasticsearch Stack'

Parameters:

  ParentStackName:
    Type: String

  CustomResourceHelperLayer:
    Type: String
  
  RequestsAWS4AuthLayer:
    Type: String

  SignupAllowedDomains:
    Type: CommaDelimitedList
    Description: Specific domains allowed to register on Kibana (Cognito User Pool)
    Default: amazon.com,amazon.co.jp

  EsVersion:
    Description: 7.x supported only
    Type: String
    Default: 7.8

  EsAvailabilityZoneCount:
    Type: Number
    Default: 2
    AllowedValues:
      - 1
      - 2
      - 3

  EsDataNodeInstanceType:
    Type: String
    Default: i3.large.elasticsearch
    AllowedPattern: ^[a-z1-9]+\.[a-z1-9]+\.elasticsearch$

  EsDataNodeInstanceCount:
    Type: Number
    Default: 2

  EsMasterNodeInstanceType:
    Type: String
    Default: t3.medium.elasticsearch
    AllowedPattern: ^[a-z1-9]+\.[a-z1-9]+\.elasticsearch$

  EsMasterNodeInstanceCount:
    Type: Number
    Default: 3
    AllowedValues: [ 3, 5 ]

Resources:

  SearchLogs: 
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/${ParentStackName}/elasticsearch/search-logs'
      RetentionInDays: 30

  IndexLogs: 
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/${ParentStackName}/elasticsearch/index-logs'
      RetentionInDays: 30

  ApplicationLogs: 
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/${ParentStackName}/elasticsearch/application-logs'
      RetentionInDays: 30

  AuditLogs: 
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/${ParentStackName}/elasticsearch/audit-logs'
      RetentionInDays: 30

  LogsResourcePolicy:
    Type: AWS::CloudFormation::CustomResource
    Version: 1.0
    Properties:
      ServiceToken: !GetAtt LogsResourcePolicyFunction.Arn
      PolicyName: !Sub 'AES-${ParentStackName}'
      PolicyDocument: !Sub |
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": "es.amazonaws.com"
              },
              "Action": [
                "logs:PutLogEvents",
                "logs:CreateLogStream"
              ],
              "Resource": [
                "${SearchLogs.Arn}",
                "${IndexLogs.Arn}",
                "${ApplicationLogs.Arn}",
                "${AuditLogs.Arn}"
              ]
            }
          ]
        }

  Elasticsearch:
    Type: AWS::Elasticsearch::Domain
    DependsOn:
      - LogsResourcePolicy
      - KibanaUserPoolDomain
    DeletionPolicy: Retain
    Properties:
      ElasticsearchVersion: !Ref EsVersion
      ElasticsearchClusterConfig:
        ZoneAwarenessEnabled: true
        ZoneAwarenessConfig:
           AvailabilityZoneCount: !Ref EsAvailabilityZoneCount
        InstanceType: !Ref EsDataNodeInstanceType
        InstanceCount: !Ref EsDataNodeInstanceCount
        DedicatedMasterEnabled: true
        DedicatedMasterType: !Ref EsMasterNodeInstanceType
        DedicatedMasterCount: !Ref EsMasterNodeInstanceCount
      #EBSOptions:
      #  EBSEnabled: !If [ EBSEnabled, true, !Ref AWS::NoValue ]
      #  VolumeSize: !If [ EBSEnabled, 100, !Ref AWS::NoValue ]
      AdvancedSecurityOptions:
        Enabled: true
        InternalUserDatabaseEnabled: false
        MasterUserOptions: 
          MasterUserARN: !GetAtt KibanaMasterRole.Arn
      CognitoOptions:
        Enabled: true
        UserPoolId: !Ref KibanaUserPool
        IdentityPoolId: !Ref KibanaIdentityPool
        RoleArn: !GetAtt CognitoAccessForAmazonES.Arn
      DomainEndpointOptions:
        EnforceHTTPS: true
        TLSSecurityPolicy: 'Policy-Min-TLS-1-2-2019-07'
      NodeToNodeEncryptionOptions:
        Enabled: true
      EncryptionAtRestOptions:
        Enabled: true
      AdvancedOptions:
        rest.action.multi.allow_explicit_index: true
      AccessPolicies: !Sub |
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "AWS": [
                  "${AWS::AccountId}"
                ]
              },
              "Action": [
                "es:*"
              ],
              "Resource": "arn:aws:es:${AWS::Region}:${AWS::AccountId}:domain/*/*"
            }
          ]
        }
      LogPublishingOptions:
        SEARCH_SLOW_LOGS:
          Enabled: true
          CloudWatchLogsLogGroupArn: !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:${SearchLogs}'
        INDEX_SLOW_LOGS:
          Enabled: true
          CloudWatchLogsLogGroupArn: !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:${IndexLogs}'
        ES_APPLICATION_LOGS:
          Enabled: true
          CloudWatchLogsLogGroupArn: !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:${ApplicationLogs}'
        AUDIT_LOGS:
          Enabled: true
          CloudWatchLogsLogGroupArn: !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:${AuditLogs}'

  CognitoAccessForAmazonES:
    Type: AWS::IAM::Role
    Properties:
      Description: 'Amazon Elasticsearch role for Kibana authentication.'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: es.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns: 
        - arn:aws:iam::aws:policy/AmazonESCognitoAccess
      Path: /service-role/

  CognitoLambdaTriggerRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action: "sts:AssumeRole"
            Principal:
              Service: lambda.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  PreSignUpTrigger:
    Type: AWS::Lambda::Function
    Properties:
      Description: 'PreSignUp Lambda Trigger for Cognito User Pool'
      Runtime: python3.7
      Role: !GetAtt CognitoLambdaTriggerRole.Arn
      Handler: index.lambda_handler
      Environment:
        Variables:
          ALLOWED_DOMAINS: !Join [',', !Ref SignupAllowedDomains] 
      Code:
        ZipFile: |
          from __future__ import print_function
          import logging
          import os

          allowed_domains = os.environ.get('ALLOWED_DOMAINS')
          logger = logging.getLogger(__name__)

          def lambda_handler(event, context):
              email = event['request']['userAttributes']['email']
              domain = email.split('@')[1]
              if allowed_domains == '*':
                  pass
              elif domain in allowed_domains.split(','):
                  pass
              else:
                  raise Exception('@{0} is not allowed to regiter.'.format(domain))
              # Return to Amazon Cognito
              return event

  PreSignUpTriggerPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt PreSignUpTrigger.Arn
      Principal: cognito-idp.amazonaws.com
      SourceArn: !GetAtt KibanaUserPool.Arn

  KibanaUserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UsernameAttributes:
        - email
      AutoVerifiedAttributes:
        - email
      Policies:
        PasswordPolicy:
          MinimumLength: 8
          RequireLowercase: true
          RequireNumbers: true
          RequireSymbols: true
          RequireUppercase: true
      Schema:
        - Name: email
          AttributeDataType: String
          DeveloperOnlyAttribute: false
          Mutable: true
          Required: true
      LambdaConfig:
        PreSignUp: !GetAtt PreSignUpTrigger.Arn

  KibanaUserPoolDomain:
    Type: AWS::Cognito::UserPoolDomain 
    Properties:
      UserPoolId: !Ref KibanaUserPool
      Domain: !Select [ 2, !Split [ '/', !Ref AWS::StackId ] ]

  KibanaIdentityPool:
    Type: AWS::Cognito::IdentityPool
    Properties:
      AllowUnauthenticatedIdentities: true

  KibanaBasicPolicy:
    Type: AWS::IAM::Policy
    Properties: 
      PolicyName: KibanaBasicPolicy
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Action:
              - 'es:ESHttp*'
            Resource:
              - !Sub '${Elasticsearch.Arn}/*'
      Roles: 
        - !Ref KibanaUserRole
        - !Ref KibanaMasterRole

  KibanaUserRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action: "sts:AssumeRoleWithWebIdentity"
            Principal:
              Federated: cognito-identity.amazonaws.com
            Condition:
              StringEquals:
                "cognito-identity.amazonaws.com:aud": !Ref KibanaIdentityPool
              ForAnyValue:StringLike:
                "cognito-identity.amazonaws.com:amr": authenticated

  KibanaMasterRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action: "sts:AssumeRole"
            Principal:
              Service: lambda.amazonaws.com
          - Effect: Allow
            Action: "sts:AssumeRoleWithWebIdentity"
            Principal:
              Federated: cognito-identity.amazonaws.com
            Condition:
              StringEquals:
                "cognito-identity.amazonaws.com:aud": !Ref KibanaIdentityPool
              ForAnyValue:StringLike:
                "cognito-identity.amazonaws.com:amr": authenticated
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  KibanaMasterUsers:
    Type: AWS::Cognito::UserPoolGroup
    Properties: 
      Description: Master users of Kibana
      GroupName: MasterUsers
      Precedence: 0
      RoleArn: !GetAtt KibanaMasterRole.Arn
      UserPoolId: !Ref KibanaUserPool

  ClientId:
    Type: AWS::CloudFormation::CustomResource
    Version: 1.0
    Properties:
      ServiceToken: !GetAtt FetchClientIdFunction.Arn
      UserPoolId: !Ref KibanaUserPool
      ClientNamePrefix: !Sub 'AWSElasticsearch-${Elasticsearch}-'

  IdentityPoolRoleAttachment:
    Type: AWS::Cognito::IdentityPoolRoleAttachment
    Properties:
      IdentityPoolId: !Ref KibanaIdentityPool
      Roles:
        authenticated: !GetAtt KibanaUserRole.Arn
      RoleMappings:
        userpool:
          IdentityProvider: !Sub '${KibanaUserPool.ProviderName}:${ClientId}'
          Type: Token
          AmbiguousRoleResolution: AuthenticatedRole

  KibanaUserRoleMapping:
    Type: Custom::RoleMapping
    Version: 1.0
    Properties:
      ServiceToken: !GetAtt ElasticsearchResourceFunction.Arn
      Host: !GetAtt Elasticsearch.DomainEndpoint
      Path: _opendistro/_security/api/rolesmapping/kibana_user
      Body: !Sub |
        {
          "backend_roles" : [
            "${KibanaUserRole.Arn}"
          ]
        }

  TweetsTemplate:
    Type: Custom::Template
    Version: 1.0
    Properties:
      ServiceToken: !GetAtt ElasticsearchResourceFunction.Arn
      Host: !GetAtt Elasticsearch.DomainEndpoint
      Path: _template/tweets
      Body: '
        {
          "index_patterns": ["tweets-*"],
          "settings": {
            "number_of_shards": 1,
            "number_of_replicas": 1
          },
          "mappings": {
            "_source": {
              "enabled": true
            },
            "properties": {
              "created_at": {
                "type": "date",
                "format": "epoch_second"
              },
              "timestamp_ms": {
                "type": "date",
                "format": "epoch_millis"
              },
              "tweetid": {
                "type": "keyword"
              },
              "text": {
                "type": "text"
              },
              "normalized_text": {
                "type": "text"
              },
              "source": {
                "type": "keyword"
              },
              "filter_level": {
                "type": "keyword"
              },
              "lang": {
                "type": "keyword"
              },
              "hashtags": {
                "type": "keyword"
              },
              "url": {
                "type": "keyword"
              },
              "quote_count": {
                "type": "long"
              },
              "reply_count": {
                "type": "long"
              },
              "retweet_count": {
                "type": "long"
              },
              "favorite_count": {
                "type": "long"
              },
              "coordinates":{
                "type": "geo_point"
              },
              "is_retweet": {
                "type": "boolean"
              },
              "is_crawled": {
                "type": "boolean"
              },
              "username": {
                "type": "keyword"
              },
              "user": {
                "properties": {
                  "id_str": {
                    "type": "keyword"
                  },
                  "name": {
                    "type": "keyword"
                  },
                  "screen_name": {
                    "type": "keyword"
                  },
                  "followers_count": {
                    "type": "long"
                  },
                  "friends_count": {
                    "type": "long"
                  },
                  "listed_count": {
                    "type": "long"
                  },
                  "favourites_count": {
                    "type": "long"
                  },
                  "favourites_count": {
                    "type": "long"
                  },
                  "lang": {
                    "type": "keyword"
                  }
                }
              },
              "comprehend": {
                "properties": {
                  "text": {
                    "type": "text"
                  },
                  "lang": {
                    "type": "keyword"
                  },
                  "sentiment": {
                    "type": "keyword"
                  },
                  "sentiment_score": {
                    "properties": {
                      "positive": { "type": "double" },
                      "negative":  { "type": "double" },
                      "neutral":  { "type": "double" },
                      "mixed":  { "type": "double" }
                    }
                  },
                  "entities": {
                    "type": "keyword"
                  },
                  "key_phrases": {
                    "type": "keyword"
                  }
                }
              },
              "mecab": {
                "properties": {
                  "keywords": {
                    "type": "keyword"
                  },
                  "wakati": {
                    "type": "keyword"
                  }
                }
              }
            }
          }
        }'

  # Custom Resources ------------------------------------
  LogsResourcePolicyFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action: "sts:AssumeRole"
            Principal:
              Service: lambda.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ResourcePolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'logs:DescribeResourcePolicies'
                  - 'logs:PutResourcePolicy'
                  - 'logs:DeleteResourcePolicy'
                Resource: '*'

  LogsResourcePolicyFunction:
    Type: AWS::Lambda::Function
    Properties:
      Description: '[Custom Resource] Resource Policy of CloudWatch Logs'
      Runtime: python3.7
      Role: !GetAtt LogsResourcePolicyFunctionRole.Arn
      Layers: 
        - !Ref CustomResourceHelperLayer
      Handler: index.lambda_handler
      Code:
        ZipFile: |
          from __future__ import print_function
          from crhelper import CfnResource
          import logging
          import json
          import boto3

          try:
              logger = logging.getLogger(__name__)
              helper = CfnResource(json_logging=False, log_level='DEBUG', boto_level='CRITICAL')
              client = boto3.client('logs')
          except Exception as e:
              helper.init_failure(e)
          
          def lambda_handler(event, context):
              print(json.dumps(event))
              helper(event, context)

          @helper.create
          def create(event, context):
              policy_name = event['ResourceProperties']['PolicyName']
              policy_document = event['ResourceProperties']['PolicyDocument']
              res = client.put_resource_policy(
                  policyName=policy_name,
                  policyDocument=policy_document
              )
              physical_resource_id = res['resourcePolicy']['policyName']
              return physical_resource_id

          @helper.update
          def update(event, context):
              old_resource_properties = event['OldResourceProperties']
              old_policy_name = old_resource_properties['PolicyName']
              policy_name = event['ResourceProperties']['PolicyName']
              policy_document = event['ResourceProperties']['PolicyDocument']
              if old_policy_name != policy_name:
                  res = client.delete_resource_policy(
                      policyName=old_policy_name
                  )
              res = client.put_resource_policy(
                  policyName=policy_name,
                  policyDocument=policy_document
              )
              physical_resource_id = res['resourcePolicy']['policyName']
              return physical_resource_id
                  
          @helper.delete
          def delete(event, context):
              policy_name = event['PhysicalResourceId']
              try:
                  res = client.delete_resource_policy(
                      policyName=policy_name
                  )
              except Exception as e:
                  logger.error(e)

  FetchClientIdFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action: "sts:AssumeRole"
            Principal:
              Service: lambda.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ListUserPoolClients
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'cognito-idp:ListUserPoolClients'
                Resource: '*'

  FetchClientIdFunction:
    Type: AWS::Lambda::Function
    Properties:
      Description: '[Custom Resource] Fetch Client ID from Cognito User Pool'
      Runtime: python3.7
      Role: !GetAtt FetchClientIdFunctionRole.Arn
      Layers: 
        - !Ref CustomResourceHelperLayer
      Handler: index.lambda_handler
      Code:
        ZipFile: |
          from __future__ import print_function
          from crhelper import CfnResource
          import logging
          import json
          import boto3

          try:
              logger = logging.getLogger(__name__)
              helper = CfnResource(json_logging=False, log_level='DEBUG', boto_level='CRITICAL')
              client = boto3.client('cognito-idp')
          except Exception as e:
              helper.init_failure(e)
          
          def lambda_handler(event, context):
              print(json.dumps(event))
              helper(event, context)
          
          @helper.create
          @helper.update
          def fetch_client_id(event, context):
              user_pool_id = event['ResourceProperties']['UserPoolId']
              client_name_prefix = event['ResourceProperties']['ClientNamePrefix']
              user_pool_clients = client.list_user_pool_clients(UserPoolId=user_pool_id)['UserPoolClients']
              for user_pool_client in user_pool_clients:
                  client_id = user_pool_client['ClientId']
                  client_name = user_pool_client['ClientName']
                  if client_name.startswith(client_name_prefix):
                      physical_resource_id = client_id
              return physical_resource_id
                  
          @helper.delete
          def delete(event, context):
              return

  # https://docs.aws.amazon.com/ja_jp/elasticsearch-service/latest/developerguide/es-request-signing.html#es-request-signing-python
  ElasticsearchResourceFunction:
    Type: AWS::Lambda::Function
    Properties:
      Description: '[Custom Resource] Modify elasticsearch resources'
      Timeout: 300
      Runtime: python3.7
      Role: !GetAtt KibanaMasterRole.Arn
      Layers: 
        - !Ref CustomResourceHelperLayer
        - !Ref RequestsAWS4AuthLayer
      Handler: index.lambda_handler
      Code:
        ZipFile: |
          from __future__ import print_function
          from crhelper import CfnResource
          import logging
          import json
          import boto3
          import os
          import requests
          from requests_aws4auth import AWS4Auth
          from time import sleep

          try:
              logger = logging.getLogger(__name__)
              helper = CfnResource(json_logging=False, log_level='DEBUG', boto_level='CRITICAL')
              region = os.environ['AWS_REGION']
              service='es'
              credentials = boto3.Session().get_credentials()
              awsauth = AWS4Auth(credentials.access_key, credentials.secret_key, region, service, session_token=credentials.token)
          except Exception as e:
              helper.init_failure(e)

          def lambda_handler(event, context):
              print(json.dumps(event))
              helper(event, context)

          @helper.create
          @helper.update
          def create(event, context):
              host = event['ResourceProperties']['Host']
              path = event['ResourceProperties']['Path']
              body = json.loads(event['ResourceProperties']['Body'])
              url = f'https://{host}/{path}'
              while True:
                  res = requests.put(url, auth=awsauth, json=body)
                  if res.status_code in [200, 201]:
                      logger.info(res.text)
                      break
                  elif res.status_code == 401:
                      logger.warning(res.text)
                      sleep(20)
                  else:
                      logger.error(res.text)
                      raise ValueError(res.text)
              physical_resource_id = url
              return physical_resource_id

          @helper.delete
          def delete(event, context):
              host = event['ResourceProperties']['Host']
              path = event['ResourceProperties']['Path']
              url = f'https://{host}/{path}'
              try:
                  res = requests.delete(url, auth=awsauth)
                  logger.info(res.text)
              except Exception as e:
                  logger.error(e)

Outputs:

  ElasticsearchArn:
    Value: !GetAtt Elasticsearch.Arn

  ElasticsearchDomainEndpoint:
    Value: !GetAtt Elasticsearch.DomainEndpoint

  ElasticsearchResourceFunctionArn:
    Value: !GetAtt ElasticsearchResourceFunction.Arn
